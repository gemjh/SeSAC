# -*- coding: utf-8 -*-
"""재헌님재헌님.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Dkjr54EOEcgU35VyTnZovxRsd6s5dGgI
"""

# =============================================
# Inference-only script: return r_cls for one patient
# =============================================

# 1) Load saved Keras model
from tensorflow.keras.models import load_model
model = load_model("/Project/Model/CLAP_model.keras")  # <-- 저장한 모델 경로 확인

# 2) Imports
import os
import numpy as np
import librosa
import tensorflow as tf
from transformers import WhisperProcessor, WhisperForConditionalGeneration
import torch

# 3) Hyper-params / constants (추론에 필요한 최소만 유지)
SAMPLE_RATE     = 16000
N_MELS          = 128
TOKEN_SEQ_LEN   = 512
TEMPERATURE     = 0  # Whisper generate 옵션 (deterministic)
device = "cuda" if torch.cuda.is_available() else "cpu"

# 4) Whisper 준비 (base 모델 기준)
processor = WhisperProcessor.from_pretrained("openai/whisper-base")
whisper_model = WhisperForConditionalGeneration.from_pretrained("openai/whisper-base").to(device)

# 5) Utils -------------------------------------------------

def wav_to_mel(wav_path, sr=SAMPLE_RATE, n_mels=N_MELS):
    """wav -> (n_mels, time, 1) Mel-spectrogram (float32)"""
    y, _ = librosa.load(wav_path, sr=sr)
    mel = librosa.feature.melspectrogram(y=y, sr=sr, n_mels=n_mels)
    mel_db = librosa.power_to_db(mel, ref=np.max)
    mel_db = mel_db[..., np.newaxis]  # (n_mels, time, 1)
    return mel_db.astype(np.float32)

def wav_to_token_ids(wav_path, sr=SAMPLE_RATE, seq_len=TOKEN_SEQ_LEN):
    """wav -> Whisper token ids (길이 seq_len, 부족시 0-padding, 넘치면 오류)"""
    y, _ = librosa.load(wav_path, sr=sr)
    inputs = processor(y, sampling_rate=sr, return_tensors="pt")
    input_features = inputs.input_features.to(device)
    pred_ids = whisper_model.generate(input_features, temperature=TEMPERATURE)
    token_ids = pred_ids[0].cpu().tolist()
    if len(token_ids) < seq_len:
        token_ids += [0] * (seq_len - len(token_ids))  # right-pad
    else:
        raise ValueError(
            f"Token sequence length {len(token_ids)} exceeds allowed maximum {seq_len}."
        )
    return np.array(token_ids, dtype=np.int32)

def discretize(pred):
    """연속(0~1) → {0.0, 0.5, 1.0} 구간화"""
    if pred < 0.25:   return 0.0
    elif pred < 0.75: return 0.5
    else:             return 1.0

def predict_scalar_score(wav_path):
    """
    단일 wav 경로를 받아 (모델 구조에 맞춰) 0~1 스칼라 예측값 반환.
    - mel_input: (1, 128, time, 1)
    - token_input: (1, TOKEN_SEQ_LEN)
    """
    mel = wav_to_mel(wav_path)             # (128, time, 1)
    tok = wav_to_token_ids(wav_path)       # (TOKEN_SEQ_LEN,)
    mel_in = mel[np.newaxis, ...]          # (1, 128, time, 1)
    tok_in = tok[np.newaxis, :]            # (1, TOKEN_SEQ_LEN)
    pred = model.predict({'mel_input': mel_in, 'token_input': tok_in}, verbose=0)
    return float(pred[0, 0])

# 6) Main API --------------------------------

def eval_one_patient_return_r_cls(
    audio="/Project/Audio/임상data(폴더명 수정)"
):
    """
    팀원이 이 함수만 호출하면 됨.
    - 입력:
        patient_id: 환자번호 (int)
        clapdata  : pandas DataFrame (열: 'number', 'total_score' 필요)
        base_dir  : 오디오 루트 경로 (무지개/그네 파일이 이 아래에 위치)
    - 동작:
        무지개(p_6_0.wav), 그네(p_9_0.wav) 파일로 모델 예측 → 이산화
        (로그는 출력하지만, 반환값은 '무지개 r_cls' 하나만 돌려줌)
    - 반환:
        r_cls (0.0 / 0.5 / 1.0)
    """
    # # 경로
    # r_wav = f"{base_dir}/{patient_id}/CLAP_A/5/p_6_0.wav"  # 무지개
    # s_wav = f"{base_dir}/{patient_id}/CLAP_A/5/p_9_0.wav"  # 그네

    # # 데이터 체크
    # if 'number' not in clapdata.columns:
    #     raise KeyError("clapdata에 'number' 컬럼이 없습니다.")
    # if 'total_score' not in clapdata.columns:

    #     raise KeyError("clapdata에 'total_score' 컬럼이 없습니다. (미리 생성 필요)")

    # row = clapdata[clapdata['number'] == patient_id]
    # if row.empty:
    #     raise ValueError(f"clapdata에 환자번호 {patient_id} 행이 없습니다.")

    # # 파일 체크(원하면 주석 처리 가능)
    # if not os.path.exists(r_wav):
    #     raise FileNotFoundError(f"무지개 파일 없음: {r_wav}")
    # if not os.path.exists(s_wav):
    #     raise FileNotFoundError(f"그네 파일 없음: {s_wav}")

    # 모델 예측 (연속값) → 이산화
    r_pred = predict_scalar_score(audio)
    # s_pred = predict_scalar_score(s_wav)
    r_cls  = discretize(r_pred)
    # s_cls  = discretize(s_pred)

    # # OR 규칙(둘 중 하나라도 1.0이면 1.0, 아니면 0.0) — 참고용 로그
    # or_val = 1.0 if (r_cls == 1.0 or s_cls == 1.0) else 0.0
    # or_str = f"{int(or_val*2)}/2"

    # # total_ratio = float(row.iloc[0]['total_score']) / 20.0
    # # print(f"{patient_id} | 무지개={r_cls} 그네={s_cls} -> OR={or_str} ({or_val:.1f}) | 실제 총점={total_ratio:.2f}")

    # 팀원 요청대로 '무지개 r_cls'만 반환
    return r_cls

# 7) Example (팀원 사용 예시)
# import pandas as pd
# clapdata = pd.read_csv("/path/to/clapdata.csv")
# # (만약 clapdata['number']가 float이면 정수로 캐스팅 권장)
# # clapdata = clapdata.dropna(subset=['number'])
# # clapdata['number'] = clapdata['number'].astype(int)
#

# r_cls = eval_one_patient_return_r_cls(audio)